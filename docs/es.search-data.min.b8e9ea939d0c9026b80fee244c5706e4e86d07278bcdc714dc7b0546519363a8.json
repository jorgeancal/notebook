[{"id":0,"href":"/es/posts/how-to-implement-sops-helmfile/","title":"Como configurar SOPS en Helmfile","section":"Posts","content":"Como veíamos por encima en nuestro anterior post sobre helmfile podemos tener un fichero en nuestro repo que este encriptado mediante sops y tener ahi las variables para usar en nuestra chart mediante Helmfile.\n¿Qué es Sops? # Si nos vamos a si proyecto veremos que Mozilla define SOPS como un editor de archivos cifrados que admite los formatos YAML, JSON, ENV, INI y BINARY. Además de soportar el cifrado de estos mediante los cifrados AWS KMS, GCP KMS, Azure Key Vault y PGP.\n¿Cómo implementarlo? # Como muchos sabréis, en esta vida todo se basa en plugins\u0026hellip;y como Helm nos deja instalar diferentes plugins solo hemos de encontrar el plugin perfecto y en este caso hay uno llamado helm-sercrets. Si buscamos este plugin en Helm Community vemos que ellos recomiendan jkroepke/helm-secrets que este es un fork de zendesk/helm-secrets pero este ultimo ha sido abandonado\u0026hellip;\nHe de decir que cuando empece a mirar este plugin fue a mediados del 2020 que para aquel entonces no estaba obsoleto. Por suerte no ha cambiado mucho su utilización y sigue siendo rápida y sencilla.\nLo primero de todo hemos de instalar las dependecias del plugin y esta es instalar SOPS. Si mal no recuerdo si tienes Ubuntu o Debian se instala solo cuando instalar el plugin pero aqui un servidor usa ArchLinux y ha de instalarlo manualmente. Yo os recomiendo que lo instaleis manualmente que no cuesta nada solo habeis de ir a los releases del repo e instalar.\nUna vez que lo habéis instalado ejecutáis el siguiente comando para instalar el plugin siendo ${HELM_SECRERS_VERSION} la última version stable del plugin.\nhelm plugin install https://github.com/jkroepke/helm-secrets --version ${HELM_SECRERS_VERSION} Una vez que tenéis esto solo habéis de ir a vuestra carpeta de helmfile y crear el siguiente fichero llamado .sops.yaml, por puesto teneis que elegir una de las tres opciones he de decir que está permitido tener multiples KSM y PGP keys.\ncreation_rules: # Encrypt with AWS KMS - kms: \u0026#39;arn:aws:kms:eu-west-1:222222222222:key/111b1c11-1c11-1fd1-aa11-a1c1a1sa1dsl1\u0026#39; # Encrypt using GCP KMS - gcp_kms: projects/mygcproject/locations/global/keyRings/mykeyring/cryptoKeys/thekey # As failover encrypt with PGP - pgp: \u0026#39;000111122223333444AAAADDDDFFFFGGGG000999\u0026#39; # For more help look at https://github.com/mozilla/sops Ahora ya solo os queda agregar el campo secrets: en vuestro fichero del release y listo. Os quedaría una cosa asi:\n- \u0026lt;\u0026lt;: *defaultTmpl name: \u0026#34;grafana\u0026#34; chart: \u0026#34;grafana/grafana\u0026#34; namespace: \u0026#34;monitoring\u0026#34; version: \u0026#34;3.2.5\u0026#34; installed: {{ .Values | getOrNil \u0026#34;grafana.installed\u0026#34; | default false }} needs: - observability/fluentd - observability/prometheus - operators/jaeger-operator secrets: - releases/grafana/secrets.yaml ¿Como usar SOPS como editor de texto? # Hay muchas formas diferentes de editar los ficheros pero yo te recomendaría que te crearas una variable de entorno y luego vayas a la carpeta donde tienes el dichero y lo abras con el siguiente comando sops secrets.yaml y sops se encarga de desencriptarlo y encriptarlo por ti.\nYo por ejemplo uso SOPS con KMS ARN por lo que tengo una variable de entorno llamada SOPS_KMS_ARN ejemplo:\nexport SOPS_KMS_ARN=arn:aws:kms:eu-west-1:222222222222:key/111b1c11-1c11-1fd1-aa11-a1c1a1sa1dsl1 Esto ha sido todo! Nos leemos!\n"},{"id":1,"href":"/es/posts/how-to-set-up-your-kluster-with-helmfle/","title":"Configurar tu kluster con Helmfile","section":"Posts","content":"Helmfile es una herramienta que te permite sacar más partido a Helm. Ya que si usas helmfile puedes implementar cualquier cantidad de helmcharts. Básicamente con helmfile declaras las helmcharts y les das los valores que tú quieres a cada una de las helm chart, helmfile creara el correspondiente deploy mediante helm para mandar a tu cluster todo lo que has definido en helmfile, claro esta puedes decirle a helmfile impleméntame solo este grupo de helmchart y de este grupo quiero implementarlas en esta secuencia.\n¿Cómo se ha portado helmfile? # Después de estos 6 meses usando helmfile la verdad es que me ha dado mucha más vida. Si queremos implementar cosas nuevas cosas\u0026hellip;. todo va más rápido.\n¿Qué me ha gustado de helmfile? # Después estar usando lo un tiempo, esto es lo que más me ha gustado de helmfile:\nLo que más vas a notar usando helmfile es que el tiempo de implementación de las helmchart habrá descendido. Por ejemplo, en donde trabajo hemos notado una mejora de 15~30 minutos comparado a lo que usábamos anteriormente que era Landscaper, actualmente obsoleto. Dejo aquí un enlace al repositorio por si alguien está interesado.\nOtra cosa que he notado es que gracias a helmfile tengo la posibilidad de tener toda la configuration de diferentes entornos en un mismo sitio. Cuando estoy trabajando con minikube y le indico que me implemente las chart con los valores que tiene para minukube lo hace sin rechistar.\ndiff. Posiblemente esto es lo mejor de todo\u0026hellip; es estúpidamente sencillo y te salva más de una vez cuando estás haciendo actualizaciones de charts o estás cambiando valores en la chart y estás seguro si te has cargado algo.\nVariables de entorno. Puedes implementar sops en helmfile pero el plugin que estaban usando lo han jubilado asi que\u0026hellip; me pase al uso de variables de entorno es lo mejor actualmente, ya que puedes tener los valores que tú quieres cuando desarrollas localmente y tener unos valores globales en tu CD/CI software. Si queréis que hable sobre la implementacion de SOPS en helmfile solo decirlo y hare otro post sobre ello.\n¿Cómo lo configuro? # La configuración es bastante sencilla. Lo primero de todo es tener un repo para todo esto o en una carpeta si vas a tener lo en un mismo repo con más cosas en él. Yo actualmente lo tengo en un repo exclusivamente para helmfile. Mi esquema del repo es el siguiente:\n. ├── addReleases.sh ├── base │ ├── defaults │ │ └── helmfile.yaml | ├── environments │ │ └── helmfile.yaml │ ├── repositories │ │ └── helmfile.yaml │ ├── templates │ │ └── template.yaml │ └── values │ ├── minikube │ │ └── values.yaml.gotmpl │ └── production │ └── values.yaml.gotmpl ├── helmfile.yaml ├── README.md └── releases ├── prometheus │ ├── helmfile.yaml │ ├── README.md │ └── values.yaml.gotmpl └── grafana ├── helmfile.yaml ├── README.md └── values.yaml.gotmpl Ahora os voy a mostrar lo que tenemos en el principal helmfile.yaml:\n{{ readFile \u0026#34;base/templates/helmfile.yaml\u0026#34; }} {{ readFile \u0026#34;base/repositories/helmfile.yaml\u0026#34; }} releases: Como veréis no tengo nada en releases y eso es porque tengo un script que va por todas las carpetas de dentro de releases y me encuentra todo fichero que se llame helmfile.yaml y me lo agrega al final del documento. De esa manera nos libramos de tener un fichero de más 200 lineas en el repo y que da más bonito a la hora de leer el fichero y te da más flexibilidad, ya que solo has de crear tu carpeta con la chart que quieres y los valores que tú quieres y listo. Os preguntaréis por qué ha puesto dos readFile ahi arriba. Bueno pues\u0026hellip; esta es la manera que encontre de mantener las cosas simples. Ya que en templates puedo crear diferentes templates para los releases y luego decirle a un release tú usa esta y tú usa la otra. Una gozada. Luego también tenemos los repositorios que como todos sabemos para declarar un repositorio en helmfile tenemos que tener dos lineas, esto quiere decir que tendríamos dos lineas más de fichero tontamente, pues mejor es tenerlo en otro fichero no? asi todo queda más limpio. A continuación os mostraré un ejemplo de los ficheros, estar atengo que uno lleva sorpresa.\nEmpezamos por el más sencillo de todo que es el de los repositorios.\nrepositories: - name: prometheus-community url: https://prometheus-community.github.io/helm-charts - name: grafana url: grafana https://grafana.github.io/helm-charts A continuacion tenemos en de la template\nbases: - base/defaults/helmfile.yaml - base/environments/helmfile.yaml templates: defaultTmpl: \u0026amp;defaultTmpl missingFileHandler: Warn valuesTemplate: - base/values/{{ .Environment.Name }}/values.yaml.gotmpl - releases/{{ .Release.Name }}/values.yaml.gotmpl Como podéis ver lleva sorpresa no solo tenemos templates tenemos la section base ahi. La verdad es que esto si queremos podríamos agregar otro fichero y poner otro readFile esto ya fue a mi gusto, ya que cuando estaba haciendo la template quería agregar la base, por lo que pensé que deberían ir juntos.\nAhora pasamos a la parte de los defaults\nhelmDefaults: wait: true timeout: 300 Ahora vamos a irnos a mirar nuestro environments.yaml. Como podéis ver, declaramos los dos entornos que tenemos y luego añadimos los valores atraves de un fichero. En este fichero le estamos indicando cuales charts queremos implementar en el entorno.\nenvironments: production: values: - base/values/production/values.yaml.gotmpl minikube: values: - base/values/minikube/values.yaml.gotmp Os dejo también un ejemplo de esto. He de comentar que este es un buen lugar para agregar variables globales para el entorno no solo para decirle que es lo que quieres instalar y lo que no.\nprometheus: installed: true grafana: installed: true A continuación vais a ver el helmfile.yaml que tengo para grafana. Es de lo más sencillo, ya que llamo a la template en el principio del release y luego agrego los datos para el release, además como veréis tenemos el campo installed que de esta manera le digo si lo quiero instalar o no y también tengo otro campo para decirle que no lo quiero implementar hasta que la lista de charts esté implementada\n- \u0026lt;\u0026lt;: *defaultTmpl name: \u0026#34;grafana\u0026#34; chart: \u0026#34;grafana/grafana\u0026#34; namespace: \u0026#34;monitoring\u0026#34; version: \u0026#34;3.2.5\u0026#34; installed: {{ .Values | getOrNil \u0026#34;grafana.installed\u0026#34; | default false }} needs: - observability/fluentd - observability/prometheus - operators/jaeger-operator Y con esto hemos terminado la configuración de helmfile.\nComo Usar Helmfile # Helmfile es muy sencillo a la hora de user vamos alli a donde tengáis un helmfile.yaml y yo os recomiendo ejecutar el siguiente comando:\nhelmfile -e minikube apply Tenéis más comandos para el uso de helmfile. Yo suelo usar bastante tempalte y diff.\nTenéis que poner siempre en entorno al que queréis implementar las charts por eso siempre que ejecutéis el comando tenéis que poner -e seguido del entorno al que vais a mandarlo, eso si, lo tenéis que tener puesto en la lista que tengáis en el fichero de entornos.\nPara terminar voy a mostraros el script que uso para buscar y agregar los ficheros al fichero principal\n#!/bin/bash for release in `find releases/ -name \u0026#34;*.yaml\u0026#34;`; do release_name=$(cat $release | grep \u0026#34;name: \u0026#34; | cut -d\u0026#39; \u0026#39; -f2-) echo \u0026#34;Templating $release\u0026#34; cat $release | sed \u0026#39;s/\\(.*\\)/ \\1/\u0026#39; \u0026gt;\u0026gt; helmfile.yaml echo \u0026gt;\u0026gt; helmfile.yaml done Si queréis ver todas los ficheros juntos y como esto funciona todo junto os dejo todo en este repo. Y esto ha sido todo senores, espero que os haya gustado y nos leemos en el próximo.\n"},{"id":2,"href":"/es/about/","title":"About","section":"Jorge's notebook","content":"Buenas,\nSoy Jorge Andreu Calatayud y esto es mi cuaderno.\nEste es mi nuevo proyecto.\nEn este blog, Intentare subir difentes post sobre las cosas que voy aprendindo y dee las cosas quee se que no es mucho pero algo es\u0026hellip; e intentare subir un post cada mes como minimo.\nNos leemos!\n"}]